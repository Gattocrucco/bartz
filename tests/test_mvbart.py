# bartz/tests/test_mvbart.py
#
# Copyright (c) 2025, The Bartz Contributors
#
# This file is part of bartz.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Test multivariate BART components."""

from dataclasses import replace

import pytest
from jax import numpy as jnp
from jax import random, vmap
from numpy.testing import assert_allclose, assert_array_equal
from scipy.stats import chi2, ks_1samp, ks_2samp

from bartz.mcmcstep import (
    Precs,
    State,
    _sample_wishart_bartlett,
    compute_likelihood_ratio_mv,
    compute_likelihood_ratio_uv,
    init,
    precompute_leaf_terms_mv,
    precompute_leaf_terms_uv,
    precompute_likelihood_terms_mv,
    precompute_likelihood_terms_uv,
    step,
    step_sigma,
    step_sigma2_prec,
    step_trees,
)
from tests.util import assert_close_matrices


class TestWishart:
    """Test the basic properties of the wishart sampler output."""

    # Parameterize with (k, df) pairs
    @pytest.fixture(params=[(1, 3), (3, 3), (3, 5), (3, 100), (100, 102)])
    def wishart_params(self, request):
        """Provide (k, df) pairs for testing."""
        k, df = request.param
        return k, df

    def random_pd_matrix(self, key, k):
        """Generate a random positive definite matrix."""
        A = random.normal(key, (k, k))
        return A @ A.T + jnp.eye(k)

    def ill_conditioned_matrix(self, key, k, condition_number=1e6, exact_psd=True):
        """Generate a ill conditioned random positive semi-definite matrix."""
        A = random.normal(key, (k, k))
        U, _ = jnp.linalg.qr(A)

        if exact_psd:
            if k == 1:
                eigs = jnp.zeros(1)
            else:
                smalls = jnp.geomspace(1.0, 1.0 / condition_number, num=k - 1)
                eigs = jnp.concatenate([smalls, jnp.array([0.0])])
        else:
            eigs = jnp.geomspace(1.0, 1.0 / condition_number, num=k)
        return (U * eigs) @ U.T

    def test_size(self, keys, wishart_params):
        """Check that the sample generated by wishart sampler is of shape k*k."""
        k, df = wishart_params
        scale = self.random_pd_matrix(keys.pop(), k)
        sample = _sample_wishart_bartlett(keys.pop(), df, scale)
        assert sample.shape == (k, k)

    def test_symmetric(self, keys, wishart_params):
        """Check that the sample generated by wishart sampler is symmetric."""
        k, df = wishart_params
        scale = self.random_pd_matrix(keys.pop(), k)
        sample = _sample_wishart_bartlett(keys.pop(), df, scale)
        assert_close_matrices(sample, sample.T, rtol=1e-6)

    def test_pos_def(self, keys, wishart_params):
        """Check that the sample generated by wishart sampler is positive definite."""
        k, df = wishart_params
        scale = self.random_pd_matrix(keys.pop(), k)
        sample = _sample_wishart_bartlett(keys.pop(), df, scale)
        eigs = jnp.linalg.eigvalsh(sample)
        assert jnp.all(eigs > 0)

    def test_near_singular_scale(self, keys, wishart_params):
        """Check that the wishart sampler still works with singular or near singular matrix."""
        k, df = wishart_params
        ill_conditioned_scale = self.ill_conditioned_matrix(keys.pop(), k)
        sample = _sample_wishart_bartlett(keys.pop(), df, ill_conditioned_scale)
        assert jnp.all(jnp.isfinite(sample))

    def test_wishart_dist(self, keys, wishart_params):
        """Check that the sample generated by wishart sampler follows a wishart distribution."""
        k, df = wishart_params
        nsamples = 1000
        sigma = self.random_pd_matrix(keys.pop(), k)
        scale_inv = jnp.linalg.inv(sigma)

        a = random.normal(keys.pop(), (k,))
        denumerator = a.T @ sigma @ a

        ts = []
        for key in random.split(keys.pop(), nsamples):
            W = _sample_wishart_bartlett(key, df, scale_inv)
            t = a.T @ W @ a / denumerator
            ts.append(t)
        ts = jnp.array(ts)

        test = ks_1samp(ts, chi2(df).cdf)
        assert test.pvalue > 0.01


class TestPrecomputeTerms:
    """Test precompute_likelihood_terms_mv and precompute_leaf_terms_mv correctness and stability."""

    @pytest.fixture(params=[1, 2, 5, 10])
    def k(self, request):
        """Provide different ks for testing."""
        return request.param

    def random_pd_matrix(self, key, k):
        """Generate a random positive definite matrix."""
        A = random.normal(key, (k, k))
        return A @ A.T + jnp.eye(k)

    def test_shapes_leaf(self, keys, k):
        """Check that shapes of outputs are correct."""
        num_trees, num_leaves = 3, 4
        prec_trees = jnp.ones((num_trees, num_leaves))
        error_cov_inv = self.random_pd_matrix(keys.pop(), k)
        leaf_prior_cov_inv = self.random_pd_matrix(keys.pop(), k)

        result = precompute_leaf_terms_mv(
            keys.pop(), prec_trees, error_cov_inv, leaf_prior_cov_inv
        )
        assert result.mean_factor.shape == (num_trees, k, k, num_leaves)
        assert result.centered_leaves.shape == (num_trees, k, num_leaves)

    def test_likelihood_equiv(self, keys):
        """Check that compute_likelihood_ratio and compute_likelihood_ratio_mv agree when k = 1."""
        inv_sigma2 = random.uniform(keys.pop(), (), minval=0.1, maxval=5.0)
        sigma_mu2 = random.uniform(keys.pop(), (), minval=0.1, maxval=5.0)
        error_cov_inv = jnp.array([[inv_sigma2]])
        leaf_prior_cov_inv = jnp.array([[1.0 / sigma_mu2]])

        precs = Precs(left=jnp.array(3.0), right=jnp.array(4.0), total=jnp.array(7.0))

        total_resid = random.normal(keys.pop(), (1,))
        left_resid = random.normal(keys.pop(), (1,))
        right_resid = random.normal(keys.pop(), (1,))

        prelkv_mv, prelk_mv = precompute_likelihood_terms_mv(
            error_cov_inv, leaf_prior_cov_inv, precs
        )
        likelihood_mv = compute_likelihood_ratio_mv(
            total_resid, left_resid, right_resid, prelkv_mv, prelk_mv
        )

        prelkv_uv, prelk_uv = precompute_likelihood_terms_uv(
            inv_sigma2, sigma_mu2, precs
        )
        likelihood_uv = compute_likelihood_ratio_uv(
            total_resid.item(),
            left_resid.item(),
            right_resid.item(),
            prelkv_uv,
            prelk_uv,
        )

        assert_allclose(prelkv_mv.sqrt_term, prelkv_uv.sqrt_term, rtol=1e-6, atol=1e-6)
        assert_allclose(likelihood_mv, likelihood_uv, rtol=1e-6, atol=1e-6)

    def test_leaf_terms_equiv(self, keys):
        """Check that precompute_leaf_terms and precompute_leaf_terms_mv agree when k = 1."""
        num_trees, num_leaves = 2, 3
        inv_sigma2 = random.uniform(keys.pop(), (), minval=0.1, maxval=5.0)
        sigma_mu2 = random.uniform(keys.pop(), (), minval=0.1, maxval=5.0)

        error_cov_inv = jnp.array([[inv_sigma2]])
        leaf_prior_cov_inv = jnp.array([[1.0 / sigma_mu2]])
        prec_trees = random.uniform(keys.pop(), (num_trees, num_leaves)) * 5.0
        z_mv = random.normal(keys.pop(), (num_trees, num_leaves, 1))
        z_uv = z_mv.squeeze(axis=-1)

        result_uv = precompute_leaf_terms_uv(
            keys.pop(), prec_trees, inv_sigma2, sigma_mu2, z_uv
        )
        result_mv = precompute_leaf_terms_mv(
            keys.pop(), prec_trees, error_cov_inv, leaf_prior_cov_inv, z_mv
        )

        assert_allclose(
            result_uv.mean_factor,
            result_mv.mean_factor.squeeze((1, 2)),
            rtol=1e-6,
            atol=1e-6,
        )
        assert_allclose(
            result_uv.centered_leaves,
            result_mv.centered_leaves.squeeze(1),
            rtol=1e-6,
            atol=1e-6,
        )


@pytest.fixture(params=[(10, 2), (20, 5), (3, 100), (50, 50)])
def data_shape(request):
    """Provide (n, p) pairs for testing."""
    return request.param


@pytest.fixture
def data(data_shape):
    """Generate a toy dataset."""
    n, p = data_shape
    X = jnp.arange(n * p).reshape(p, n)
    y = jnp.linspace(-1, 1, n)
    max_split = jnp.full(p, 5, dtype=jnp.uint32)
    return X, y, max_split


class TestMVBartIntegration:
    """Test equivalence between Univariate and Multivariate (k=1) modes."""

    def test_init_equivalence(self, data):
        """Test that init produces compatible structures for UV and MV(k=1)."""
        X, y, max_split = data
        y_mv = y[None, :]
        p_nonterminal = jnp.array([0.9, 0.5], dtype=jnp.float32)

        common = dict(
            X=X,
            max_split=max_split,
            num_trees=10,
            p_nonterminal=p_nonterminal,
            sigma_mu2=1.0,
            resid_batch_size=None,
            count_batch_size=None,
            filter_splitless_vars=False,
        )

        bart_uv = init(y=y, sigma2_alpha=3.0, sigma2_beta=2.0, **common)

        bart_mv = init(
            y=y_mv,
            leaf_prior_cov_inv=jnp.array([[1.0]], dtype=jnp.float32),
            error_cov_df=jnp.array(6.0, dtype=jnp.float32),
            error_cov_scale=4.0 * jnp.eye(1, dtype=jnp.float32),
            **common,
        )

        assert bart_uv.kind == 'uv'
        assert bart_uv.inv_sigma2 is not None
        assert bart_uv.error_cov_inv is None

        assert bart_mv.kind == 'mv'
        assert bart_mv.inv_sigma2 is None
        assert bart_mv.error_cov_inv is not None

        assert bart_uv.resid.ndim == 1
        assert bart_mv.resid.ndim == 2
        assert bart_mv.resid.shape[0] == 1
        assert bart_mv.resid.shape[1] == bart_uv.resid.shape[0]

        assert jnp.ndim(bart_uv.inv_sigma2) == 0
        assert bart_mv.error_cov_inv.shape == (1, 1)

        assert_array_equal(bart_uv.resid, bart_mv.resid.squeeze(0))
        assert_array_equal(bart_uv.forest.var_tree, bart_mv.forest.var_tree)
        assert_array_equal(bart_uv.forest.split_tree, bart_mv.forest.split_tree)
        assert_array_equal(
            bart_uv.forest.leaf_tree, bart_mv.forest.leaf_tree.squeeze(1)
        )
        assert_array_equal(bart_uv.forest.leaf_indices, bart_mv.forest.leaf_indices)
        assert_array_equal(bart_uv.forest.p_nonterminal, bart_mv.forest.p_nonterminal)
        assert_array_equal(bart_uv.forest.p_propose_grow, bart_mv.forest.p_propose_grow)
        assert_array_equal(bart_uv.forest.affluence_tree, bart_mv.forest.affluence_tree)

    def test_step_sigma_distribution_match(self, keys, data):
        """
        Test that step_sigma and step_sigma2_prec (k = 1) sample from the same posterior.

        UV: 1/sigma2 ~ Gamma(alpha_post, beta_post)
        MV: error_cov_inv ~ Wishart(df_post, scale_post)
        """
        X, y, _ = data
        resid = random.normal(keys.pop(), (y.size,))

        alpha_prior_uv = 10.0
        beta_prior_uv = 5.0

        st_uv = State(
            X=X,
            y=y,
            resid=resid,
            kind='uv',
            sigma2_alpha=alpha_prior_uv,
            sigma2_beta=beta_prior_uv,
            z=None,
            offset=0.0,
            inv_sigma2=1.0,
            error_cov_inv=None,
            prec_scale=None,
            error_cov_df=None,
            error_cov_scale=None,
            forest=None,
        )

        df_prior_mv = 2 * alpha_prior_uv
        scale_prior_mv = 2 * beta_prior_uv

        st_mv = State(
            X=X,
            y=y[None, :],
            resid=resid[None, :],
            kind='mv',
            error_cov_df=jnp.array(df_prior_mv),
            error_cov_scale=jnp.array([[scale_prior_mv]]),
            z=None,
            offset=0.0,
            inv_sigma2=None,
            error_cov_inv=jnp.eye(1),
            prec_scale=None,
            sigma2_alpha=None,
            sigma2_beta=None,
            forest=None,
        )

        def sample_uv(k):
            return step_sigma(k, st_uv).inv_sigma2

        def sample_mv(k):
            return step_sigma2_prec(k, st_mv).error_cov_inv[0, 0]

        n_samples = 10000
        samples_uv = vmap(sample_uv)(keys.pop(n_samples))
        samples_mv = vmap(sample_mv)(keys.pop(n_samples))

        _, p_value = ks_2samp(samples_uv, samples_mv)

        assert jnp.abs(jnp.mean(samples_uv) - jnp.mean(samples_mv)) < 0.01
        assert p_value > 0.01


class TestMVBartSteps:
    """Test the full MCMC step trajectory (init + multiple steps)."""

    def test_step_trees_exact_match(self, keys, data):
        """Test that MV tree logic is Identical to UV logic."""
        X, y, max_split = data
        y_mv = y[None, :]
        n_trees = 100

        params = dict(
            X=X,
            max_split=max_split,
            num_trees=n_trees,
            p_nonterminal=jnp.array([0.9, 0.5]),
            sigma_mu2=1 / n_trees,
            resid_batch_size=None,
            count_batch_size=None,
            filter_splitless_vars=False,
        )

        uv_state = init(y=y, sigma2_alpha=2.0, sigma2_beta=1.0, kind='uv', **params)
        mv_state = init(
            y=y_mv,
            leaf_prior_cov_inv=n_trees * jnp.eye(1),
            error_cov_df=jnp.array(4.0),
            error_cov_scale=2 * jnp.eye(1),
            kind='mv',
            **params,
        )

        mv_state = replace(
            mv_state,
            resid=uv_state.resid[None, :],
            error_cov_inv=jnp.array([[uv_state.inv_sigma2]]),
            forest=replace(
                mv_state.forest,
                var_tree=uv_state.forest.var_tree,
                split_tree=uv_state.forest.split_tree,
                leaf_tree=uv_state.forest.leaf_tree[:, None, :],
                leaf_indices=uv_state.forest.leaf_indices,
                affluence_tree=uv_state.forest.affluence_tree,
            ),
        )

        key = keys.pop()
        uv_next = step_trees(key, uv_state)
        mv_next = step_trees(random.clone(key), mv_state)

        assert_close_matrices(
            uv_next.resid, mv_next.resid.squeeze(0), atol=1e-6, rtol=1e-6
        )
        assert_close_matrices(
            uv_state.forest.leaf_tree,
            mv_state.forest.leaf_tree.squeeze(1),
            atol=1e-6,
            rtol=1e-6,
        )

        assert_array_equal(uv_state.forest.var_tree, mv_state.forest.var_tree)
        assert_array_equal(uv_state.forest.split_tree, mv_state.forest.split_tree)
        assert_array_equal(uv_state.forest.leaf_indices, mv_state.forest.leaf_indices)
        assert_array_equal(
            uv_state.forest.affluence_tree, mv_state.forest.affluence_tree
        )

        assert_array_equal(
            uv_state.forest.grow_prop_count, mv_state.forest.grow_prop_count
        )
        assert_array_equal(
            uv_state.forest.grow_acc_count, mv_state.forest.grow_acc_count
        )
        assert_array_equal(
            uv_state.forest.prune_prop_count, mv_state.forest.prune_prop_count
        )
        assert_array_equal(
            uv_state.forest.prune_acc_count, mv_state.forest.prune_acc_count
        )

    def test_mv_steps(self, keys, data):
        """Test that mv mode can run without crashing."""
        X, y_uv, max_split = data
        k = 3

        y = jnp.tile(y_uv, (k, 1))
        y = y + random.normal(keys.pop(), y.shape) * 0.1

        mv_state = init(
            X=X,
            y=y,
            max_split=max_split,
            num_trees=5,
            p_nonterminal=jnp.array([0.9, 0.5]),
            sigma_mu2=1.0,
            leaf_prior_cov_inv=jnp.eye(k),
            error_cov_df=jnp.array(10.0),
            error_cov_scale=jnp.eye(k),
            resid_batch_size=None,
            count_batch_size=None,
            kind='mv',
            filter_splitless_vars=False,
        )

        for key in random.split(keys.pop(), 10):
            mv_state = step(key, mv_state)

            assert jnp.all(jnp.isfinite(mv_state.resid))
            assert jnp.all(jnp.isfinite(mv_state.error_cov_inv))
            assert jnp.all(jnp.isfinite(mv_state.forest.leaf_tree))

            assert mv_state.error_cov_inv.shape == (k, k)
            assert mv_state.resid.shape == (k, y.shape[1])
